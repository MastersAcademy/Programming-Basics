#### Класс `Часы`
    свойство размер
	свойство вес
	свойство средний_рабочий_срок

#### Класс `Солнечные_часы` наследуется от класса `Часы`
	свойство ошибка_в_расчетах
	метод показать_время
	
#### Класс `Песочные_часы` наследуется от класса `Часы`
	свойство количество_отсчитуемого_времени
	метод перевернуть_часы
	метод показать_состояние

#### Класс `Электронные_часы` наследуется от класса `Часы`
	свойство количество_заряда
	свойство материал_корпуса
	свойство средний_рабочий_срок
	метод показать_время
	
#### Класс `Человек`
	свойство количество_прожитых_секунд
	свойство имя
	
#### Класс `Пользователь_часов` наследуется от класса `Человек`
	метод купить_часы
	метод зарядить_часы
	метод смотреть_время
	
#### Класс `Дворник` наследуется от класса `Пользователь_часов`
	метод отдать_в_ремонт_часы

#### Класс `Часовщик` наследуется от класса `Пользователь_часов`
	метод ремонтировать_часы

#### Класс `Продавец_часов`	наследуется от класса `Пользователь_часов`
	метод продать_часы

***

#### Пример объектов

объект1=`Дворник`(Антон, 30000 количество_прожитых_секунд)
объект1.купить_часы(`Электронные_часы`)

объект2=`Продавец_часов`(Денис, 50000 количество_прожитых_секунд)
объект2.купить_часы(`Песочные_часы`)

объект3=`Часовщик`(Сергей, 100000 количество_прожитых_секунд)
объект3.купить_часы(`Солнечные_часы`)


#### Принцып полиморфизма
У классов `Cолнечные_часы` и `Электронные_часы` есть один метод - `показать_время`. 
При этом солнечные часы не всегда могут что-то вообще показать из-за погоды,
а электронные могут показывать в темноте.. метод один результат разный

объект1.смотреть_время(`Электронные_часы`.показать_время)
объект3.смотреть_время(`Солнечные_часы`.показать_время)

#### Принцып инкапсуляции
Не понятно как работают электронные_часы, там много механизмов, но нам важно что они показывают время.
Внутренний механизм скрыт от пользователя.

#### SOLID
1. Single Responsibility. Класс `Дворник`, `Часовщик`, `Продавец_часов` имеют одну обязанность
2. Open-Closed. Я думаю мои классы расширяемы.
3. Liskov Substitution. Наследуемые классы не противоречат поведению базовых классов. Если появятся часы которые будут без веса или без размера, или не будут иметь средний рабочий срок, тогда эти часы не смогут наследоваться от моего класса `Часы`.
4. Interface Segregation. Базовые классы не имеют методов в моей программе, дабы не пришлось объявлять их в каждом наследнике
5. Dependency Invertion. Метод `смотреть_время` не зависит от конкретных часов