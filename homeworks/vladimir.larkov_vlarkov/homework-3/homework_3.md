# **Класс: настольная лампа**
***
### __ООП__

* _Инкапсуляция_  - я не знаю о внутреннем устройстве лампы, я просто нажимаю выключатель и свет горит.
(выключатель это метод "светить" интерфейса, который реализуют все источники 
света или метод абстрактного класса Источник света от которого наследуются все источники
света).

* _Наследование_  - у лампы есть родительский класс, например, абстрактный класс
Источник света, с методом "светить". Лампа реализует у себя этот метод. Улампы может
быть дочерний клас - "умная" лампа с подключениемк сети(она кроме метода "светить"
имеет методы для работы в сети).

* _Полиморфизм_  -  я могу взять набор(массив, список т.д.) разных наследников класса Источник света и
поочередно вызывать у них метод "светить". При этом кажныйиз них будет
светить согласно своей реализации метода "светить".

### __SOLID__

* _Single Responsibility Principle (Принцип единственной обязанности)_ - предназначение
настольной лампы только светить.

* _Open Closed Principle (Принцип открытости/закрытости)_ - я хочу сделать чтобы "умная" настольная лампа
могла использовать WiFi модули разных производителей, по-этому в классе "умной"
лампы я буду использовать интерфейс ПодключениеКWiFi вместо конкретного модуля. 
Теперь в открытый метод подключения к сети можно передавать не конкретный модуль WiFi, а 
любой объект, реализующий интерфейс ПодключениеКWiFi. Т.е. можно менять 
модули WiFi в создаваемых объектах класса "умная" настольная лампа, без изменения
самого класса.

* _Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков)_ - 
если я заменю настольную лампу торшером(наследник Источника света) я смогу
использовать для техже целей, что и настольную лампу.

* _Interface Segregation Principle (Принцип разделения интерфейса)_ - 
настольная лампа  например реализует метод "светить" интерфейса Свечение. "Умная"
лампа тоже реализует этот интерфейс. Но "умная" лампа "знает", как подключитьсяк сети
в отличие от настольной. Чтобы не мешать в интерфейсе Свечение методы для
освещения и подключения к сети "умная" лампа реализует также интерфейс ПодключениеКСети,
а настольная только Свечение.

* _Dependency Inversion Principle (Принцип инверсии зависимостей)_ - возьмем к примеру
"умную" настольную лампу.  Она содежит модуль WiFi и модуль освещения. Эти модули
включены в класс "умной" настольной лампы не как определенные классы(например
WiFi модуль от компании Леново), которые возможно надо будет менять, а от интерфейсов,
которые эти модули реализуют. Т.е. если WiFi модуль от компании Леново имеет дефекты, мы смело 
его меняем на WiFi модуль от компании Хуавей реализующий тот же интерфейс, что 
и модуль от Леново. При этом НИЧЕГО не меняя в классе "умной" настольной лампы.
Т.е. имеем зависимость от абстракций(интерфейсы), а не деталей(конкретные классы WiFi модулей).